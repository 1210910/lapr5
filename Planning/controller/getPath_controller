:- module(getPath_controller, [get_path/3]).


:- use_module('../service/map_service').
:- use_module('../persistence/DB').

% get the path

get_path(Start, End, Response) :-
    atom_string(StartStr, Start), % Convertendo Start para string, se não for
    atom_string(EndStr, End),     % Convertendo End para string, se não for
    map_service:carrega_conexoes,
    map_service:create_floors,
    map_service:create_elevators,
    map_service:create_corridors,
    db:room(StartStr, StartFloor),
    db:room(EndStr, EndFloor),
    write('StartFloor: '), writeln(StartFloor),
    write('EndFloor: '), writeln(EndFloor),
    map_service:path_floors(StartFloor, EndFloor, PathBuilding, PathFloors),
    write('Path: '), writeln(PathFloors),
    map_service:get_all_floors(PathFloors,AllFloors),
    write('Path: '), writeln(AllFloors),
    map_service:get_entry_exit_positions(AllFloors,EntryExitPositions),
    write('Path: '), writeln(EntryExitPositions),
    map_service:process_path(EntryExitPositions,_,ResultPath),
    write('Path: '), writeln(ResultPath),
    write('PathBuilding: '), writeln(PathBuilding),
    write('PathFloors: '), writeln(PathFloors),
    % criar a resposta
    format_response(ResultPath, PathBuilding, PathFloors, Response).

format_response(ResultPath, PathBuilding, PathFloors, Response) :-
    % Cria o termo JSON com os campos especificados
    term_to_string(ResultPath, ResultPathString),
    term_to_string(PathBuilding, PathBuildingString),
    term_to_string(PathFloors, PathFloorsString),
    Response = json{
    path:ResultPathString,
    building:PathBuildingString,
    floor:PathFloorsString
    }.

result_path_to_string(ResultPath, ResultString) :-
        atomic_list_concat(ResultPath, ',', ResultString).

term_to_string(Term, String) :-
    with_output_to(string(String), write_term(Term, [quoted(true)])).


