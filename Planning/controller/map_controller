:- module(map_controller, [converte_mapa/1]).

:- use_module('../persistence/DB').

converte_mapa(X):-
    db:map(X, Y,_,_),
    converte_mapa(Y).

converte_mapa(Mapa) :-
    converte_mapa_linhas(Mapa, 1).

converte_mapa_linhas([], _).
converte_mapa_linhas([Linha | Resto], Lin) :-
    converte_linha(Linha, 1, Lin),
    NextLine is Lin + 1,
    converte_mapa_linhas(Resto, NextLine).

converte_linha([], _, _).
converte_linha([Celula | Resto], Col, Lin) :-
    (Celula =:= 0 ->
        assertz(m(Col, Lin, 0))
    ;
        assertz(m(Col, Lin, Celula))
    ),
    NextCol is Col + 1,
    converte_linha(Resto, NextCol, Lin).

numero_maximo_linhas(Matriz, NumeroLinhas) :-
    length(Matriz, NumeroLinhas).

numero_maximo_colunas(Matriz, NumeroColunas) :-
        length(Matriz, NumeroLinhas),
        (   NumeroLinhas > 0,
            nth1(1, Matriz, PrimeiraLinha),
            length(PrimeiraLinha, NumeroColunas)
        ;   NumeroColunas is 0
        ).

cria_grafo(X):-
    db:map(X, Y,_,_),
    numero_maximo_linhas(Y, Linhas),
    numero_maximo_colunas(Y, Colunas),
    cria_grafo(Colunas,Linhas).


cria_grafo(_,0):-!.
cria_grafo(Col,Lin):-cria_grafo_lin(Col,Lin),Lin1 is Lin- 1,cria_grafo(Col,Lin1).
cria_grafo_lin(0,_):-!.
cria_grafo_lin(Col,Lin):-m(Col,Lin,0),!,
ColS is Col+1, ColA is Col-1, LinS is Lin+1,LinA is Lin-1,
((m(ColS,Lin,0),assertz(ligacel(cel(Col,Lin),cel(ColS,Lin)));true)),
((m(ColA,Lin,0),assertz(ligacel(cel(Col,Lin),cel(ColA,Lin)));true)),
((m(Col,LinS,0),assertz(ligacel(cel(Col,Lin),cel(Col,LinS)));true)),
((m(Col,LinA,0),assertz(ligacel(cel(Col,Lin),cel(Col,LinA)));true)),
(m(ColS,LinS,0),assertz(ligacel(cel(Col,Lin),cel(ColS,LinS)));true)),
((m(ColA,LinA,0),assertz(ligacel(cel(Col,Lin),cel(ColA,LinA)));true)),
((m(ColS,LinA,0),assertz(ligacel(cel(Col,Lin),cel(ColS,LinA)));true)),
((m(ColA,LinS,0),assertz(ligacel(cel(Col,Lin),cel(ColA,LinS)));true)),
Col1 is Col-1,
cria_grafo_lin(Col1,Lin).
cria_grafo_lin(Col,Lin):-Col1 is Col-1,cria_grafo_lin(Col1,Lin).

dfs(Orig,Dest,Cam):-
       dfs2(Orig,Dest,[Orig],Cam).
dfs2(Dest,Dest,LA,Cam):-
       reverse(LA,Cam).
dfs2(Act,Dest,LA,Cam):-ligacel(Act,X),\+ member(X,LA), dfs2(X,Dest,[X|LA],Cam).
all_dfs(Orig,Dest,LCam):-findall(Cam,dfs(Orig,Dest,Cam),LCam).
better_dfs(Orig,Dest,Cam):-all_dfs(Orig,Dest,LCam), shortlist(LCam,Cam,_).
shortlist([L],L,N):-!,length(L,N). shortlist([L|LL],Lm,Nm):-shortlist(LL,Lm1,Nm1),
length(L,NL),
((NL<Nm1,!,Lm=L,Nm is NL);(Lm=Lm1,Nm is Nm1)).

carrega_conexoes :-
    findall(passageway(X, Y, Z), db:passageway(X, Y, Z), Passagens), % Encontra todas as passagens carregadas
    processa_passagens(Passagens). % Processa as passagens para criar as conexões entre os edifícios

processa_passagens([]). % Caso base, quando não há mais passagens para processar
processa_passagens([passageway(_, Y, Z) | Resto]) :-
    atom_chars(Z, [Edificio2, _ | _]), % Extrai a letra do edifício A
    atom_chars(Y, [Edificio1, _ | _]), % Extrai a letra do edifício B
    assertz(liga(Edificio2, Edificio1)),% Cria a conexão entre os edifícios
    assertz(liga(Edificio1, Edificio2)),% Cria a conexão entre os edifícios
    processa_passagens(Resto). % Processa o restante das passagens recursivamente


path_buildings(BdOr,BdDest,LBdPath):-path_buildings2(BdOr,BdDest,[BdOr],LBdPath).
path_buildings2(BdX,BdX,LBdInv,LBdPath):-!,reverse(LBdInv,LBdPath).
path_buildings2(BdAct,BdDest,LBdPassed,LBdPath):-(liga(BdAct,BdInt);liga(BdInt,BdAct)), \+member(BdInt,LBdPassed), path_buildings2(BdInt,BdDest,[BdInt|LBdPassed],LBdPath).


all_path_buildings(BdOr,BdDest,LTPathBd):-findall(LBdPath,path_buildings(BdOr,BdDest,LBdPath),LTPathBd).



% Método para criar os fatos floors/2 a partir de floor/3
create_floors :-
    findall(Building-FloorCodes, floors_building(Building, FloorCodes), BuildingFloorsList),
    create_floors_facts(BuildingFloorsList).

% Método para encontrar todos os códigos de andares de um edifício
floors_building(Building, FloorCodes) :-
    setof(Code, Number^floor(Code, Number, Building), FloorCodes).

% Método para criar os fatos floors/2 a partir da lista de Building-FloorCodes
create_floors_facts([]).
create_floors_facts([Building-FloorCodes | Rest]) :-
    assertz(floors(Building, FloorCodes)),
    create_floors_facts(Rest).


% Método para criar os fatos elevator/2 a partir de lift/3
create_elevators :-
    findall(Building-Floors, lift(_, Building, Floors), BuildingFloorsList),
    create_elevator_facts(BuildingFloorsList).

% Método para criar os fatos elevator/2 a partir da lista de Building-Floors
create_elevator_facts([]).
create_elevator_facts([Building-Floors | Rest]) :-
    assertz(elevator(Building, Floors)),
    create_elevator_facts(Rest).


% Método para criar os fatos corridor/4 a partir de passageway/3
create_corridors :-
    findall(Floor1-Floor2, passageway(_, Floor1, Floor2), CorridorList),
    create_corridor_facts(CorridorList).

% Método para criar os fatos corridor/4 a partir da lista de Building1-Building2-Floor1-Floor2
create_corridor_facts([]).
create_corridor_facts([Floor1-Floor2 | Rest]) :-
    atom_chars(Floor1, [Building1Code | _]), % Extrai o primeiro caractere do código do andar para o código do edifício
    atom_chars(Floor2, [Building2Code | _]), % Extrai o primeiro caractere do código do andar para o código do edifício
    assertz(corridor(Building1Code, Building2Code, Floor1, Floor2)),
    create_corridor_facts(Rest).

room_location(3,2).

extract_building_floor(RoomCode, BuildingCode, FloorCode) :-
    atom_chars(RoomCode, [BuildingCode | Rest]),
    append([BuildingCode], FloorChars, Rest),
    atom_chars(FloorCode, FloorChars).

get_all_floors(LCon, AllFloors) :-
        findall(Floor, (
            member(cell(_, _, Floor), LCon), % Extrai o piso de cada célula em LCon
            atom_chars(Floor, [BuildingCode | _]), % Extrai o código do edifício
            atom_chars(Floor, [_, FloorCode | _]), % Extrai o código do piso
            % Monta o código completo do piso
            atom_concat(BuildingCode, FloorCode, FullFloorCode),
            % Adiciona o código completo do piso à lista de pisos
            \+ member(FullFloorCode, AllFloors), % Verifica se o piso já foi adicionado
            AllFloors = [FullFloorCode | Rest] % Adiciona o piso à lista
        ), AllFloors).

% Predicado para determinar a posição de entrada/saída nos pisos
get_entry_exit_positions([First | Rest], EntryExitPositions) :-
    get_entry_exit_positions([First | Rest],  EntryExitPositions).

% Se for o primeiro
get_entry_exit_positions([First, Last], EntryExitPositions) :-
    room_location(X, Y),
    EntryRoom = cel(X, Y),
    ExitRoom = cel(X, Y),
    map(First, _,ExitEntry,_),
    [EntryLast , ExitFirst ] = ExitEntry,
    EntryExitFirst = cam(First, EntryRoom, ExitFirst),
    EntryExitLast = cam(Last, EntryLast, ExitRoom),
    append(EntryExitFirst, EntryExitLast, EntryExitPositions).

get_entry_exit_positions([Floor1| Rest], EntryExitPositions) :-
    (
        [Floor2 | _] = Rest,
        is_same_building_transition(Floor1,Floor2) ->
            db:map(Floor, _, _, Exit),
            db:map(Floor, _, Entry, _),
            % o entry é um array de arrays , e eu quero apenas o primeiro elemento do primeiro array
            [FirstEntry | _] = Entry,
            EntryExitPosition = cam(Floor, FirstEntry, Exit)
        ; % Outros tipos de transições
            db:map(Floor, _, ExitEntry, _),
            [Entry , Exit ] = ExitEntry,
            EntryExitPosition = cam(Floor, Entry, Exit)
    ),
    EntryExitPositions = [EntryExitPosition | RestEntryExitPositions],
    get_entry_exit_positions(Rest, RestEntryExitPositions).

% Lógica para identificar se é uma transição no mesmo edifício (considerada elevador)
is_same_building_transition(Floor1, Floor2) :-
    atom_chars(Floor1, [Building1Code | _]),
    atom_chars(Floor2, [Building2Code | _]),
    Building1Code == Building2Code.

% Predicado para percorrer a lista de transições
process_path([]).
process_path([cam(Floor, Entry, Exit) | Rest],Path) :-
    cria_grafo(Floor),
    better_dfs(Entry, Exit, Cam),
    Caminho = cam(Floor, Cam),
    append(Caminho, Path),
    process_transitions(Rest,Path).





path_floors(FloorOr,FloorDest,LBdPath,LCon):-
    floors(BdOr,LFloorOr),member(FloorOr,LFloorOr),
    floors(BdDest,LFloorsDest),member(FloorDest,LFloorsDest), path_buildings(BdOr,BdDest,LBdPath), follow_floors(FloorOr,FloorDest,LBdPath,LCon).
    follow_floors(FloorDest,FloorDest,_,[]).
follow_floors(FloorDest1,FloorDest,[BdDest],[elev(FloorDest1,FloorDest)]):-
    FloorDest\==FloorDest1, elevator(BdDest,LFloors),member(FloorDest1,LFloors), member(FloorDest,LFloors).
follow_floors(FloorAct,FloorDest,[BdAct,BdNext|LOthersBd],[cor(FloorAct,FloorNext)|LOtherCon]):-
    (corridor(BdAct,BdNext,FloorAct,FloorNext);corridor(BdNext,BdAct,FloorNext,FloorAct)), follow_floors(FloorNext,FloorDest,[BdNext|LOthersBd],LOtherCon).
follow_floors(FloorAct,FloorDest,[BdAct,BdNext|LOthersBd], [elev(FloorAct,FloorAct1),cor(FloorAct1,FloorNext)|LOtherCon]):-
    (corridor(BdAct,BdNext,FloorAct1,FloorNext); corridor(BdNext,BdAct,FloorNext,FloorAct1)),FloorAct1\==FloorAct, elevator(BdAct,LFloors),member(FloorAct,LFloors),member(FloorAct1,LFloors), follow_floors(FloorNext,FloorDest,[BdNext|LOthersBd],LOtherCon).



